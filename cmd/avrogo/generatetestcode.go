// +build ignore

// This program generates all the test code in internal/generated_tests from
// the Cue data in the testdata directory. It's run from go generate
// via generate_test.go.
package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"go/format"
	"io"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"text/template"

	"github.com/heetch/avro/cmd/avrogo/internal/avrotestdata"
)

var testCodeTemplate = template.Must(
	template.New("").
		Delims("«", "»").
		Funcs(template.FuncMap{
			"quote":   quote,
			"mapKeys": mapKeys,
		}).
		Parse(`
// Code generated by generatetestcode.go; DO NOT EDIT.

package «.TestName»

import (
	"testing"

	"github.com/heetch/avro/cmd/avrogo/internal/testutil"
)

var tests = testutil.RoundTripTest{
	InSchema: «quote .InSchema»,
	GoType: new(«.GoType»),
	Subtests: []testutil.RoundTripSubtest{
		«- range $k := mapKeys .Subtests»
		«- $t := index $.Subtests $k»{
			TestName: «printf "%q" $t.TestName»,
			InDataJSON: «quote $t.InData»,
			OutDataJSON: «quote $t.OutData»,
			«with $t.ExpectError -»
			ExpectError: map[testutil.ErrorType]string{
			«- range $k, $v := .»«quote $k»: «quote $v»,«end»},
			«end»
		}, «end»},
}

«if .GoTypeBody -»
type «.GoType» «.GoTypeBody»
«end»

func TestGeneratedCode(t *testing.T) {
	tests.Test(t)
}
`[1:]))

const generateDir = "internal/generated_tests"

func mapKeys(m map[string]avrotestdata.Subtest) (ks []string) {
	for k := range m {
		ks = append(ks, k)
	}
	sort.Strings(ks)
	return ks
}

func main() {
	tests, err := avrotestdata.Load("./testdata")
	if err != nil {
		log.Fatalf("cannot load test data: %v", err)
	}
	os.RemoveAll(generateDir)
	failed := false
	for _, test := range tests {
		errorf := func(f string, a ...interface{}) {
			fmt.Fprintf(os.Stderr, "generatetestcode: test %q: %s\n", test.TestName, fmt.Sprintf(f, a...))
		}
		fatalf := func(f string, a ...interface{}) {
			errorf(f, a...)
			os.Exit(1)
		}
		check := func(what string, err error) {
			if err != nil {
				fatalf("%s: %v", what, err)
			}
		}
		dir := filepath.Join(generateDir, test.TestName)
		err := os.MkdirAll(dir, 0777)
		check("mkdir", err)
		if test.OutSchema != nil {
			var schemaFiles []string
			schemas := []json.RawMessage{test.OutSchema}
			schemas = append(schemas, test.ExtraSchemas...)
			for i, schema := range schemas {
				var f string
				if i == 0 {
					f = "schema.avsc"
				} else {
					f = fmt.Sprintf("schema%d.avsc", i)
				}
				file := filepath.Join(dir, f)
				err = ioutil.WriteFile(file, schema, 0666)
				check("create schema file", err)
				schemaFiles = append(schemaFiles, f)
			}
			var buf bytes.Buffer
			args := []string{"-p", test.TestName, "schema.avsc"}
			args = append(args, schemaFiles...)
			cmd := exec.Command("avrogo", args...)
			cmd.Stderr = &buf
			cmd.Stdout = &buf
			cmd.Dir = dir
			err = cmd.Run()
			if test.GenerateError != "" {
				if err == nil {
					errorf("avrogo unexpectedly succeeded in dir", dir)
					failed = true
					continue
				} else {
					pat, err := regexp.Compile("^(" + test.GenerateError + ")\n?$")
					check("generateError regexp", err)
					if !pat.MatchString(buf.String()) {
						errorf("avrogo failed with unexpected error;\ngot %q\nwant %q\n", &buf, test.GenerateError)
						failed = true
						continue
					}
				}
				// If there's an expected generation error, we don't want the
				// test directory any more.
				err := os.RemoveAll(dir)
				check("remove dir", err)
				continue
			}
			if err != nil {
				io.Copy(os.Stderr, &buf)
			}
			check(fmt.Sprintf("test %s: avrogo %q", test.TestName, args), err)
		} else {
			// The Go tool seems to require at least some
			// non-test code, at least when run with coverage engaged.
			err = ioutil.WriteFile(filepath.Join(dir, "dummy.go"), []byte("package "+test.TestName+"\n"), 0666)
			check("write dummy", err)
		}
		var buf bytes.Buffer
		err = testCodeTemplate.Execute(&buf, test)
		check("generate test code", err)
		goSource, fmtErr := format.Source(buf.Bytes())
		if fmtErr != nil {
			goSource = buf.Bytes()
		}
		outFile := filepath.Join(dir, "roundtrip_test.go")
		err = ioutil.WriteFile(outFile, goSource, 0666)
		check("write test go file", err)
		if fmtErr != nil {
			check("gofmt test code "+outFile, fmtErr)
		}
		if test.OtherTests != "" {
			otherTest, err := format.Source([]byte(test.OtherTests))
			check("format other tests", err)
			err = ioutil.WriteFile(filepath.Join(dir, "other_test.go"), otherTest, 0666)
			check("write other tests", err)
		}
	}
	if failed {
		os.Exit(1)
	}
}

func quote(b interface{}) string {
	var s string
	switch b := b.(type) {
	case []byte:
		s = string(b)
	case json.RawMessage:
		s = string(b)
	case string:
		s = b
	default:
		panic(fmt.Errorf("cannot quote %T", b))
	}
	if !strings.Contains(s, "`") {
		return "`" + s + "`"
	}
	return strconv.Quote(s)
}
